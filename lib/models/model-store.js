import fs from "../fs.js";
import path from "../path.js";

// js-schema-tools dependencies
import { equals } from "../equals/equals.js";
import * as diff from "../diff/diff.js";
import * as basicSchema from "../schema/basic-js-schema.js";
import { makeMigration } from "../schema/migrations/make-migration.js";

// circular dependency for the win.
import { Model, Models } from "./models.js";

// A set of "singleton" instances for models, so
// that we can consult them for any schema-related
// tasks a model might need to perform.
export const MODEL_SCHEMA = {};

/**
 * Instantiate a model and then convert its schema form
 * to a proper (validation-controlled) data object.
 */
export function instantiateModel(Model, storePath) {
  recordModelClass(Model);
  const model = new Model();
  fromSchemaToData(model);
  Object.defineProperty(model, `storePath`, {
    enumerable: false,
    configurable: false,
    value: storePath,
  });
  return model;
}

/**
 * Record the model singleton for schema-related work,
 * and (try to) tie this into the associated schema
 * from the filesystem.
 *
 * - If no saved schema, save one.
 * - If saved schema matches, nice.
 * - If it does not, save a version-bumped schema
 *   and create a migration file.
 */
export function recordModelClass(Model, storePath = Models.storePath) {
  const { name } = Model;

  if (!MODEL_SCHEMA[name]) {
    const schema = new Model();

    // Is this the same schema as was previously stored?
    const stored = loadSchema(schema, storePath);

    if (stored) {
      const diffs = diff.create(stored, schema);
      if (diffs.length) {
        // It is not! Someone's going to have to run data migrations
        // before this model can be safely used with preexisting data.
        const err = new Error(
          `Schema mismatch for ${name} model, please migrate your data first.`
        );
        err.diffs = diffs.map((v) => {
          delete v.fn;
          delete v.rollback;
          return v;
        });

        // So let's be nice: save the new schema to file and create a
        // migration runner so that the data can be uplifted.
        // saveSchema(Model);
        saveSchema(Model, stored.__meta.version + 1);
        generateMigrationFile(stored, schema, storePath);

        // And then error out.
        throw err;
      }
    } else saveSchema(Model);

    // Add a local binding on the model class.
    Model.schema = schema;

    // And store a global binding for other code to reference.
    MODEL_SCHEMA[name] = schema;
  }
}

/**
 * Load a model's stored schema, so we can check whether it's the same as before.
 * @param {*} schema
 * @returns the schema object, or undefined if there is no stored schema
 */
function loadSchema(schema, storePath = Models.storePath) {
  const dir = `${storePath}/${schema.__meta.name}/.schema/`;
  const { name } = schema.__proto__.constructor;
  return basicSchema.getLatestSchema(dir, name);
}

/**
 * Generate a migration file that can be run with Node to uplift
 * data files from one schema to another.
 */
function generateMigrationFile(schema1, schema2, storePath = Models.storePath) {
  const migration = makeMigration(schema1, schema2);
  const from = schema1.__meta.version;
  const filename = `${schema2.__proto__.constructor.name}.v${from}.to.v${
    from + 1
  }.js`;
  let filepath = `${storePath}/${schema2.__meta.name}/${filename}`;
  filepath = path.normalize(filepath);
  fs.writeFileSync(filepath, `import fs from "fs";\n${migration}`, `utf-8`);
  console.error(`Autogenerated migration [${filepath}]`);
}

/**
 * Save a model's schema to disk (for now, but different backends in the future)
 * @param {*} schema
 */
function saveSchema(Model, storePath = Models.storePath) {
  // Turn monolithic schema into a set of linked schema
  const schema = new Model();

  // how many distinct schema are we actually working with?
  const schemaSet = makeLinkedSchemaSet(schema);

  // generate new files for the updated schema.
  schemaSet.forEach((entry) => {
    const { schema, __meta } = entry;
    schema.__meta = __meta;
    const schemaName = schema.__proto__.constructor.name;

    // Make sure we have a dir to write to
    const dir = `${storePath}/${__meta.name}/.schema`;
    fs.mkdirSync(dir, { recursive: true });

    // Is this (sub)schema the same as the previous version?
    // Because it's possible a change in the overall schema does
    // not actually change anything in a distinct subschema, or vice
    // versa, and there's no point in a new, but "the same", file.

    let newVersion = 1;
    const stored = basicSchema.getLatestSchemaFilePath(dir, schemaName);

    if (stored.version) {
      newVersion = stored.version + 1;
      const { filepath } = stored;
      const s1 = fs.readFileSync(filepath).toString();
      const s2 = schema.toString();
      if (equals(s1, s2)) return;
    }

    // This is not the same data as the previously stored version.
    const newfilepath = `${dir}/${schemaName}.${newVersion}.json`;

    // Write the schema to file, iF it doesn't already exist, because
    // linked schema might already have a stored schema file.
    if (!fs.existsSync(newfilepath)) {
      fs.writeFileSync(newfilepath, schema.toString());
    }
  });
}

/**
 * Decompose a single schema into a set of linked schema, based
 * on the __meta.distinct property of modelfields with a .shape
 *
 * @param {*} schema
 * @returns array of linked schema
 */
function makeLinkedSchemaSet(schema) {
  const list = [{ schema, __meta: schema.__meta }];

  (function iterate(s) {
    Object.entries(s).forEach(([key, value]) => {
      const { __meta, shape } = value;
      if (shape) {
        if (__meta?.distinct) {
          list.push({ schema: shape, __meta });
          s[key] = {
            __meta: {
              schema: shape.__proto__.constructor.name,
              schemaName: __meta.name,
            },
          };
        } else {
          iterate(shape);
        }
      }
    });
  })(schema);

  return list;
}

/**
 * Rewrite a model from its initial "schema" layout
 * to the actually usable "controlled data" layout.
 */
export function fromSchemaToData(model) {
  const props = Object.entries(model);
  props.forEach(([key, definition]) => {
    if (definition.shape) definition = definition.shape;

    // we don't need to retain metadata, this is instead
    // kept around in the Models.modelTrees dictionary.
    if (key === `__meta`) {
      delete model.__meta;
    }

    // nested models need their own rewrite pass
    else if (definition instanceof Model) {
      Object.defineProperty(model, key, {
        configurable: false,
        value: definition,
        writable: false,
      });
      fromSchemaToData(definition);
    }

    // everything else is a simple (validation-controlled) property
    else {
      let __proxy = definition.default;
      Object.defineProperty(model, key, {
        configurable: false,
        get: () => __proxy,
        set: (value) => {
          const result = validateField(key, value, definition);
          if (result.passed) {
            __proxy = value;
          } else {
            const err = new Error(
              `Could not assign key "${key}" value "${value}".`
            );
            err.errors = result.errors;
            throw err;
          }
        },
      });
    }
  });

  Object.defineProperty(model, `__converted`, {
    configurable: false,
    value: true,
  });
}

/**
 * Field validation function based on conform()
 */
function validateField(key, value, definition, strict = false) {
  const schema = {
    [key]: {
      __meta: definition.__meta,
      type: definition.type,
      default: definition.default,
    },
  };

  [`choices`].forEach((k) => {
    const v = definition[k];
    if (v !== undefined) schema[key][k] = v;
  });

  return basicSchema.validate(schema, { [key]: value }, strict);
}
